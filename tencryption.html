<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="stylesMain.css">
    <script src="navdropdown.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script> <!-- master highlighting import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script> <!-- python highlighting import -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"> <!-- github code styling theme -->
    <script>hljs.highlightAll();</script>

    <title>Tencyption</title>
</head>
<body>
<div class="main">
    <nav>
        <div class="navdiv1">
            tenthdragon103.github.io/tencryption
        </div>
        <div class="navdiv2">
            Tencryption
        </div>
        <div class="navdiv3">
            <div class="dropdown">
                <button class="plus-button" id="plusButton">
                    <div class="line horizontal"></div>
                    <div class="line vertical"></div>
                </button>
                <div class="dropdown-content" id="userdropdown">
                    <a onclick="history.back()">Back</a>
                    <a href="index.html">Main page</a>
                    <a href="about.html">About Me</a>
                    <a href="wtjdabot.html">Biggest Project</a>
                    <a href="CVEReport.html">CVE Report</a>
                    <a href="projects.html">Other Projects</a>
                    <button id="darkModeToggle" class="toggle-btn">Toggle Dark Mode</button>
                </div>
            </div>
        </div>
    </nav>

    <main class="content-wrapper">
        <section class="content-section">
            <p>
                This project was created for my cyber security class, submitted with code, an essay on how it works, and examples. The examples have been omitted here.
            </p>
        </section>
        <section class="content-section">
            <h3>Essay</h3>
            <p style="text-indent: 40px;">
                The program has three modes, encryption, decryption, and key generation. The encryption is a key-based algorithm that scrambles a file's bytes by a series of functions generated by the key. To begin, the key is read as bytes into the memory and verified as a valid key by matching the beginning and end bytes, which remain constant in all keys as a signature. The signature bytes are then removed, and the remaining bytes are used for functions needing the key. This method ensures that any modifications to the key result in a bad signature or failure to decrypt. Then the given input file, such as a text file, is read into the program's memory as bytes to be encrypted per byte. The program will then create the specified output file or otherwise open it to be overwritten, and will begin writing. For each byte, a key index is calculated by two times the byte index plus one, quantity modulo key length. This makes the key index step by two and wrap around the key for each byte of data. The action to take on the byte for encryption is chosen by taking the previous key index’s byte and using the first two bits as the identifier. The action variable value is gotten by taking the raw byte of the key index times two plus one quantity modulo key length. These two values, the action identifier and action variable, are used to choose and apply a function to the byte. Actions indexed zero through two are add, subtract, and XOR acting on the data byte using the key byte. This encrypted byte is then put through the same process with reversed indexes, the first key byte being the action variable value and the second key byte being the action. This double encrypted data byte is then written to the output file and the loop continues with the next byte until the end of the dataset.
            </P>
            <p style="text-indent: 40px;">
                Decryption is a largely similar process, the encrypted file is read in as bytes, the key file is read in as bytes and stripped of its signature, and the decryption begins byte by byte. However, instead of repeating the same function with the same value in the same order, to decrypt the byte it must have its secondary encryption function undone. This, like the encryption process, is chosen by the key. The key index is gotten with the function 2 times the data byte index plus one quantity modulo the key length. Its first encryption is then undone by the same selection of functions by using the first bits of the key byte, but inverted. What previously was add, subtract, and XOR, is now subtract, add, and XOR, with XOR being the inverse to its own function. Next, the data byte’s primary encryption is reversed with the same set of functions but using the new key byte gotten by the function two times the data byte index quantity modulo the key length. The fully unencrypted data byte is then written to a provided output file, and the program loops over every encrypted data byte until the end of the file.
            </P>
            <p style="text-indent: 40px;">
                Arguably the most important part of the process of encryption and decryption is the key. The key must be random, it must contain instructions to encrypt and decrypt data, and it must be feasibly globally unique. The key created by tencrypt.py is 395 bytes and is generated using a mixture of pseudo-random numbers, human randomization, and the Python secrets module which takes from the system's Cryptographically Secure Pseudo-Random Number Generator. The values used are the character number, which is the Unicode number code for a randomly selected value in the user’s provided human randomization, a pseudo-random multiplier, a pseudo-random dividend, and a CSPRNG ‘true’ random exponent below 256. A byte is generated by the function character number multiplied by the random multiplier floor divided by the random dividend, quantity to the power of the CSPRNG number quantity modulo 256. This acquisition of randomization is repeated 256 times and written to the output file, appending and prepending the key’s signature. This key generation ensures maximum randomization and efficiency for fast generation and security of use.
            </P>
            <p style="text-indent: 40px;">
                In summary, the program generates a randomized key to prevent reverse engineering of the key or prediction of it by using multiple factors in said randomization. This signed key is used to encrypt or decrypt any file by applying randomized functions defined by the key to scramble bytes into unreadable garbage for any potential malicious watcher of communications. The same key is used to encrypt as well as decrypt a file, as the inverse operations used to encrypt are used for decryption. The program also keeps the size of the file intact, meaning no inflation or using extra memory to encrypt a large file.
            </p>
        </section>

        <style>
            .code-container {
                max-height: 50vh;
                overflow-y: auto;
                border-radius: 8px;
                border: 1px solid #444;
                padding: 10px;
                background-color: #0d1117;
            }
        </style>

        <h3>Code (Python 3)</h3>
        <div class="code-container">
        <pre><code class="language-python">import sys
import os
import random
import secrets
import tkinter
from tkinter import *


def generate_key(outputFile, garbage=None):
    """Generate a randomized key for encryption and decryption and save it to the specified location

    Perameters:
        outputFile - File to save key to
        ?garbage - Random user input to skip prompt

    Returns:
        None
    """
    while not garbage:
        garbage = input("Keyboard spam for randomization please: ")

    with open(outputFile, "wb") as f:
        f.write(b"TBK-BEGIN")
        for i in range(256):
            cnum = ord(random.choice(garbage))  # random char to int
            mul = random.randint(1, 100)
            div = random.randint(1, 100) # AI also told me to use secrets for better randoms
            rand_byte = ((cnum * mul // div) ^ secrets.randbelow(256)) % 256 # the Scrambler TM
            f.write(bytes([rand_byte]))
        f.write(b"TBK-END")
    print(f"Key written to {outputFile}")

generate_key.__doc__ = "generate a key using random user input and save the key file"


def validate_key(keyFile):
    """Validate a key's signature

    Perameters:
        keyFile - Path of the key file

    Returns:
        boolean - valid or not
    """
    with open(keyFile, "rb") as f:
        data_bytes = f.read()
        return (data_bytes.startswith(b"TBK-BEGIN") and data_bytes.endswith(b"TBK-END"))

validate_key.__doc__ = "check if prefix and suffix exist and return boolean value"


def get_key(keyFile):
    """Read a key from the specified file

    Perameters:
        keyFile - Path of the key file

    Returns:
        bytes - key data with prefix and suffix removed
    """
    with open(keyFile, "rb") as f:
        data_bytes = f.read()
        return data_bytes.removeprefix(b"TBK-BEGIN").removesuffix(b"TBK-END")

get_key.__doc__ = "get key bytes after removing prefix and suffix"


def get_input_bytes(inputFile): # AI assisted method
    """Read the byte data from inputFile

    Perameters:
        intputFile - Path of the input file

    Returns:
        bytes
    """
    with open(inputFile, "rb") as f:
        data_bytes = f.read()
    return data_bytes

get_input_bytes.__doc__ = "read input file as bytes"


def encrypt_file(inputFile, outputFile, keyFile):
    """Encrypt a file using specified key and save it to outputFile

    Perameters:
        keyFile - Path of the key file
        outputFile - Path of the output file
        inputFile - Path of the input file

    Returns:
        None
    """
    print("Encrypting...")
    key = get_key(keyFile)
    data = get_input_bytes(inputFile)

    with open(outputFile, "wb") as f:
        for index, byte in enumerate(data):
            encrypted_byte = encrypt_byte(byte, key, index)

            kIndex = key[(2 * index + 1) % len(key)]
            double_encrypted_byte = encrypt_byte(encrypted_byte, key, kIndex)

            f.write(bytes([double_encrypted_byte]))


def encrypt_byte(byte, key, index):
    """Encrypt a single byte

    Perameters:
        byte - the byte to encrypt
        key - a validated key used to encrypt
        index - the position in the key or data the byte is

    Returns:
        byte - encrypted byte
    """
    action = key[(2 * index) % len(key)] & 0b11
    x = key[(2 * index + 1) % len(key)]
    return apply_function(byte, action, x)


def apply_function(byte, action, x):
    """Apply an encryption math function to a byte

    Perameters:
        byte - the byte to change
        action - the index of the math function
        x - the variable to use in the functions with the byte

    Returns:
        byte - the changed byte
    """
    match action:
        case 0:  # mod
            return (byte + x) % 256
        case 1:  # mult
            return (byte - x) % 256
        case 2:  # xor
            return byte ^ (x % 256)
        case _:
            return byte


def decrypt_file(inputFile, outputFile, keyFile):
    """Decrypt a file using specified key and save it to outputFile

    Perameters:
        keyFile - Path of the key file
        outputFile - Path of the output file
        inputFile - Path of the input file

    Returns:
        None
    """
    print("Decrypting...")
    key = get_key(keyFile)
    data = get_input_bytes(inputFile)

    with open(outputFile, "wb") as f:
        for index, byte in enumerate(data):
            kIndex = key[(2 * index + 1) % len(key)]
            first_decrypted_byte = decrypt_byte(byte, key, kIndex)

            decrypted_byte = decrypt_byte(first_decrypted_byte, key, index)
            f.write(bytes([decrypted_byte]))


def decrypt_byte(byte, key, index):
    """Decrypt a single byte

    Perameters:
        byte - the byte to encrypt
        key - a validated key used to decrypt
        index - the position in the key or data the byte is

    Returns:
        byte - decrypted byte
    """
    action = key[(2 * index) % len(key)] & 0b11
    x = key[(2 * index + 1) % len(key)]
    return undo_function(byte, action, x)


def undo_function(byte, action, x):
    """Apply a reverse encryption math function to a byte

    Perameters:
        byte - the byte to change
        action - the index of the math function
        x - the variable to use in the functions with the byte

    Returns:
        byte - the changed byte
    """
    match action:
        case 0:  # undo add
            return (byte - x) % 256
        case 1:  # undo modulus
            return (byte + x) % 256
        case 2: # xor reverses xor
            return byte ^ (x % 256)
        case _:
            return byte


def init_gui():
    """Initialize the GUI process

    Perameters:
        None

    Returns:
        None
    """
    r = tkinter.Tk()
    r.title('Tenception')
    color = "lightgreen"
    font = ("Ariel", 15)


    key_button = Button(r, text='GENERATE KEY', width=40, font=font, command=lambda: on_start_gen(in_entry, out_entry, key_button, response_label), background=color)
    key_button.grid(row=4, column=0)
    button = Button(r, text='START', width=40, font=font, command=lambda: on_start(key_entry, in_entry, out_entry, button, response_label), background=color)
    button.grid(row=3, column=0)

    response_label = Label(r, width=40, font=font)
    response_label.grid(row=3, column=1)
    key_label = Label(r, text="Key", font=font).grid(row=0, column=0)
    in_label = Label(r, text="Input File", font=font).grid(row=1, column=0)
    out_label = Label(r, text="Output File", font=font).grid(row=2, column=0)

    key_entry = Entry(r, font=font, width=40)
    key_entry.grid(row=0, column=1)

    in_entry = Entry(r, font=font, width=40)
    in_entry.grid(row=1, column=1)

    out_entry = Entry(r, font=font, width=40)
    out_entry.grid(row=2, column=1)

    r.mainloop()


def on_start_gen(in_entry, out_entry, key_button, response_label):
    """Helper method for the GUI to begin key generation process with visual feedback

    Perameters:
        in_entry - tkinter Entry object for input file
        out_entry - tkinter Entry object for output file
        key_button - tkinter Button object for key file
        response_label - tkinter Label object for response

    Returns:
        None
    """
    outputFile = out_entry.get()
    input_junk = in_entry.get()

    if not outputFile:
        response_label.config(text="Key output file must go in Output")
        key_button.config(background="red")
        return

    output_parent = os.path.dirname(outputFile)

    if not outputFile.endswith(".key"):
        response_label.config(text="Output file must be a .key")
        key_button.config(background="red")
        return
    if not os.access(output_parent, os.W_OK):
        response_label.config(text=f"Cannot write to '{output_parent}'")
        key_button.config(background="red")
        return

    if not input_junk:
        response_label.config(text="Please keyboard spam in input for randomization")
        key_button.config(background="red")
        return

    key_button.config(background="lightgreen")
    response_label.config(text="Key saved")
    generate_key(outputFile, garbage=input_junk)


def on_start(key_entry, in_entry, out_entry, button, response_label):
    """Helper method for the GUI to begin encryption process with visual feedback

    Perameters:
        key_entry - tkinter Entry object for key file
        in_entry - tkinter Entry object for input file
        out_entry - tkinter Entry object for output file
        key_button - tkinter Button object for key button
        response_label - tkinter Label object for response

    Returns:
        None
    """
    keyFile = key_entry.get()
    inputFile = in_entry.get()
    outputFile = out_entry.get()

    if not keyFile.endswith(".key"):
        response_label.config(text="Key file must be a .key")
        button.config(background="red")
        return
    if not os.path.isfile(keyFile):
        response_label.config(text="Key file not found")
        button.config(background="red")
        return
    if not inputFile or not os.path.isfile(inputFile):
        response_label.config(text="Input file not found")
        button.config(background="red")
        return
    if not outputFile:
        response_label.config(text="Output file path required")
        button.config(background="red")
        return

    is_encrypt = True
    if inputFile.endswith(".enc"):
        is_encrypt = False
    elif not inputFile.endswith(".txt"):
        response_label.config(text="Input must be .txt for encryption")
        button.config(background="red")
        return

    if outputFile.endswith(".txt"):
        is_encrypt = False
        if is_encrypt:
            response_label.config(text="Output must be .enc for encryption")
            button.config(background="red")
            return
    elif outputFile.endswith(".enc"):
        if not is_encrypt:
            response_label.config(text="Output must be .txt for decryption")
            button.config(background="red")
            return
    else:
        response_label.config(text="Output must be .txt for decryption or .enc for encryption")
        button.config(background="red")
        return

    output_parent = os.path.dirname(outputFile)
    if not os.access(output_parent, os.W_OK):
        response_label.config(text=f"Cannot write to '{output_parent}'")
        button.config(background="red")
        return

    if not validate_key(keyFile):
        response_label.config(text="Invalid key signature")
        button.config(background="red")
        return

    # Call encryption or decryption
    if is_encrypt:
        encrypt_file(inputFile, outputFile, keyFile)
    else:
        decrypt_file(inputFile, outputFile, keyFile)
    response_label.config(text="Operation completed successfully!")
    button.config(background="lightgreen")



man = """
NAME
    Tencrypt - encryption tool

SYNOPSIS
    tencrypt.py [options]
    tencrypt.py --genkey=dir
    tencrypt.py --input=dir [output option] [key option]
    tencrypt.py --output=dir [input option] [key option]
    tencrypt.py --key=dir [input option] [output option]
    tencrypt.py --help

DESCRIPTION
    Encryption tool for generating TBK encryption keys and using TBK keys to encrypt or decrypt data.

OPTIONS
    genkey - Generate a key to the specified directory. Give an absolute path and extension. Use alone
    input - Specify input file to be used for encryption or decryption. Must be enc for decryption or txt for encryption
    output - Specify output file to be used for encryption or decrypion. Must be enc for decryption or txt for encryption
    key - Specify the key file to be used for processing algorithms. Must be key
    help - Help page

EXAMPLES
    tencrypt.py --genkey=C:/Users/user/Dowloads/new_key.key
    tencrypt.py --input=/home/user/Downloads/encrpyted_message.enc --key=/home/user/.ssh/tencrypt_key.key --output=/tmp/output.txt
    tencrypt.py --key=C:/Users/user/.ssh/my_key.key

EXIT STATUS
    0   Program success
    1   Improper input
    2   Permissions error
    3   Encryption key error

HISTORY
    2025 - Tenthdragon103, sole author with minor ChatGPT assistance for math functions and python syntax.

BUGS
    I hope not
"""

def parse_cli():
    """parse command line arguments to begin encryption or key generation processes

    Permameters:
        None

    Returns:
        outputFile - Output file directory
        inputFile - Input file directory
        keyFile - Key file directory
        output_parent - Output file parent directory
    """
    outputFile, inputFile, keyFile, output_parent = "", "", "", ""
    for arg in sys.argv[1:]:
        if arg == "--help" or arg == "-h":
            print(man) # print manual
            sys.exit(0)
        elif arg.startswith("--genkey="):
            # generate new keypair
            outputFile = arg[len("--genkey="):]

            output_parent = os.path.dirname(outputFile)
            if not outputFile.endswith(".key"):
                print("Key file must be a .key. exiting")
                sys.exit(1)
            if not os.access(output_parent, os.W_OK):
                print(f"Cannot write to '{output_parent}'. exiting")
                sys.exit(2)

            generate_key(outputFile)
            sys.exit(0)
        #endif genkey

        # check input
        elif arg.startswith("--input="):
            if inputFile:
                print("Duplicate input file found. exiting")
                sys.exit(1)
            inputFile = arg[len("--input="):]

        # check output
        elif arg.startswith("--output="):
            if outputFile:
                print("Duplicate output file found. exiting")
                sys.exit(1)
            outputFile = arg[len("--output="):]

        # check key
        elif arg.startswith("--key="):
            if keyFile:
                print("Duplicate key file found. exiting")
                sys.exit(1)
            keyFile = arg[len("--key="):]

        # default to unknown arg
        else:
            print(f"Unknown argument '{arg}'. exiting")
            sys.exit(1)
    #endfor arg loop

    # prompt for unspecified paths
    if not inputFile:
        inputFile = input("Type full input file path: ")
    if not outputFile:
        outputFile = input("Type full output file path: ")
    if not keyFile:
        keyFile = input("Type full key file path: ")
    return outputFile, inputFile, keyFile, output_parent



def run_as_cli():
    """begin encryption or key generation processes from CLI

    Permameters:
        None

    Returns:
        None
    """
    outputFile, inputFile, keyFile, output_parent = parse_cli()

    is_encrypt = True
    # filetype and procedure checks
    if not (inputFile.endswith(".txt") or inputFile.endswith(".enc")):
        print("Input file must be a .txt or .enc. exiting")
        sys.exit(1)
    if inputFile.endswith(".enc"):
        is_encrypt = False


    if outputFile.endswith(".txt"):
        is_encrypt = False
    elif outputFile.endswith(".enc"):
        if not is_encrypt:
            print("Output file must be a .txt for decryption. exiting")
            sys.exit(1)
    else:
        print("Output file must be a .txt or .enc. exiting")
        sys.exit(1)


    if not keyFile.endswith(".key"):
        print("Key file must be a .key. exiting")
        sys.exit(1)


    # access/existence checks
    output_parent = os.path.dirname(outputFile)
    if not os.access(output_parent, os.W_OK):
        print(f"Cannot write to '{output_parent}'. exiting")
        sys.exit(2)
    if not os.path.isfile(inputFile):
        print(f"Invalid input path '{inputFile}'. exiting")
        sys.exit(1)
    if not os.path.isfile(keyFile):
        print(f"Invalid key path '{keyFile}'. exiting")
        sys.exit(1)


    if not validate_key(keyFile):
        print("Invalid key signature. exiting")
        sys.exit(3)


    if (is_encrypt):
        encrypt_file(inputFile, outputFile, keyFile)
    else:
        decrypt_file(inputFile, outputFile, keyFile)



if __name__ in {"__main__", "__mp_main__"}:
    """Entry point of the code to validate arguements and request user input

    Perameters:
        "--genkey=dir" - Generate a key to the specified directory. Give an absolute path and extension
        "--input=dir" - Specify input file to be used for encryption or decryption. Must be enc for decryption or txt for encryption
        "--output=dir" - Specify output file to be used for encryption or decrypion. Must be enc for decryption or txt for encryption
        "--key=dir" - Specify the key file to be used for processing algorithms. Must be key
        "--help" - Help page
        no perams - Open graphical interface
    """

    if len(sys.argv) <= 1:
        init_gui()
    else:
        run_as_cli()
        </code></pre>
        </div>
    </main>
</div>
</body>
</html>